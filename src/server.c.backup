#include <stdio.h>
#include "game_logic.h"
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <pthread.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include "game_state.h"

// Declare Member 2's functions

// Global variables
volatile sig_atomic_t server_running = 1;
GameState *game_state = NULL;

// Signal handlers
void handle_sigint() {
    printf("\n[MAIN] Shutting down...\n");
    server_running = 0;
}

void handle_sigchld() {
    while (waitpid(-1, NULL, WNOHANG) > 0);
}

// Logger thread function
void* logger_thread_func(void* arg) {
    (void)arg;  // Mark parameter as unused
    printf("[LOGGER] Thread started (TID: %ld)\n", (long)pthread_self());
    
    int heartbeat = 0;
    while (server_running) {
        sleep(2);
        printf("[LOGGER] Heartbeat %d\n", ++heartbeat);
    }
    
    printf("[LOGGER] Thread exiting\n");
    return NULL;
}

// Client process handler
void handle_client_process(int player_id) {
    printf("[CHILD %d] Player %d starting\n", getpid(), player_id);
    
    // Mark as connected
    sem_wait(game_state->turn_sem);
    game_state->players[player_id - 1].connected = true;
    game_state->players[player_id - 1].active = true;
    game_state->connected_count++;
    sem_post(game_state->turn_sem);
    
    printf("[CHILD %d] Connected. Total: %d/3 needed\n", 
           getpid(), game_state->connected_count);
    
    // Wait for minimum players
    while (game_state->connected_count < 3 && server_running) {
        sleep(1);
    }
    
    // Start game when enough players
    if (server_running && game_state->connected_count >= 3) {
        // Only first player initializes game
        if (player_id == 1) {
            printf("[CHILD %d] Starting game...\n", getpid());
            init_game_round(game_state);
        } else {
            printf("[CHILD %d] Waiting for game start...\n", getpid());
        }
        
        // Wait for game to be active
        while (!game_state->game_active && server_running) {
            sleep(1);
        }
    }
    
    // Game loop
    int round = 1;
    while (server_running && game_state->game_active) {
        printf("[CHILD %d] Player %d round %d\n", getpid(), player_id, round);
        
        // Check if it's this player's turn
        sem_wait(game_state->turn_sem);
        if (game_state->current_turn == player_id - 1) {
            PlayerState *player = &game_state->players[player_id - 1];
            
            if (!player->standing && player->points <= 21) {
                printf("[CHILD %d] Player %d's turn! Points: %d\n",
                       getpid(), player_id, player->points);
                
                // Simple AI decision
                if (player->points < 16) {
                    printf("[CHILD %d] Player %d HIT\n", getpid(), player_id);
                    player_hit(game_state, player_id);
                } else {
                    printf("[CHILD %d] Player %d STAND\n", getpid(), player_id);
                    player_stand(game_state, player_id);
                }
            }
        }
        sem_post(game_state->turn_sem);
        
        round++;
        
        // Check if game ended
        if (!game_state->game_active) {
            printf("[CHILD %d] Game ended\n", getpid());
            break;
        }
        
        sleep(2);
    }
    
    // Clean exit
    sem_wait(game_state->turn_sem);
    game_state->players[player_id - 1].connected = false;
    game_state->players[player_id - 1].active = false;
    game_state->connected_count--;
    sem_post(game_state->turn_sem);
    
    printf("[CHILD %d] Exiting\n", getpid());
    exit(0);
}

int main() {
    printf("=== Blackjack Server ===\n");
    printf("PID: %d\n", getpid());
    
    // Setup signals
    signal(SIGINT, (void (*)(int))handle_sigint);
    signal(SIGCHLD, (void (*)(int))handle_sigchld);
    
    // Initialize shared memory
    game_state = init_shared_memory();
    if (!game_state) {
        fprintf(stderr, "Failed to init shared memory\n");
        return 1;
    }
    
    // Create threads
    pthread_t scheduler_thread, logger_thread;
    
    // Create scheduler thread (Member 2's function)
    if (pthread_create(&scheduler_thread, NULL, scheduler_thread_func, (void*)game_state) != 0) {
        perror("Failed to create scheduler thread");
        cleanup_shared_memory();
        return 1;
    }
    
    // Create logger thread
    if (pthread_create(&logger_thread, NULL, logger_thread_func, NULL) != 0) {
        perror("Failed to create logger thread");
        cleanup_shared_memory();
        return 1;
    }
    
    printf("[MAIN] Threads created. Waiting for players...\n");
    printf("[MAIN] Need 3 players to start game\n");
    
    // Fork player processes
    for (int i = 1; i <= 3 && server_running; i++) {
        pid_t pid = fork();
        
        if (pid < 0) {
            perror("fork");
            continue;
        }
        
        if (pid == 0) {
            // Child process
            handle_client_process(i);
        } else {
            // Parent process
            printf("[MAIN] Forked player %d (PID: %d)\n", i, pid);
        }
        
        sleep(1);  // Delay between forks
    }
    
    // Main loop
    while (server_running) {
        sleep(1);
        
        // Print game state periodically
        static int print_counter = 0;
        if (++print_counter % 5 == 0) {
            print_game_state(game_state);
        }
    }
    
    // Cleanup
    printf("\n[MAIN] Cleaning up...\n");
    
    // Wait for threads to finish
    pthread_join(scheduler_thread, NULL);
    pthread_join(logger_thread, NULL);
    
    // Cleanup shared memory
    cleanup_shared_memory();
    
    printf("[MAIN] Server stopped\n");
    return 0;
}
